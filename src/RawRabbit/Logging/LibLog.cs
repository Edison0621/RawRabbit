//===============================================================================
// LibLog
//
// https://github.com/damianh/LibLog
//===============================================================================
// Copyright © 2011-2015 Damian Hickey.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//===============================================================================

// ReSharper disable PossibleNullReferenceException

// Define LIBLOG_PORTABLE conditional compilation symbol for PCL compatibility
//
// Define LIBLOG_PUBLIC to enable ability to GET a logger (LogProvider.For<>() etc) from outside this library. NOTE:
// this can have unintended consequences of consumers of your library using your library to resolve a logger. If the
// reason is because you want to open this functionality to other projects within your solution,
// consider [InternalsVisibleTo] instead.
// 
// Define LIBLOG_PROVIDERS_ONLY if your library provides its own logging API and you just want to use the
// LibLog providers internally to provide built in support for popular logging frameworks.

#pragma warning disable 1591

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("RawRabbit.Enrichers.RetryLater")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.Get")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.MessageSequence")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.Publish")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.Request")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.Respond")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.StateMachine")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.Subscribe")]
[assembly: InternalsVisibleTo("RawRabbit.Operations.Tools")]
[assembly: SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "RawRabbit.Logging")]
[assembly: SuppressMessage("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed", Scope = "member", Target = "RawRabbit.Logging.Logger.#Invoke(RawRabbit.Logging.LogLevel,System.Func`1<System.String>,System.Exception,System.Object[])")]

// If you copied this file manually, you need to change all "RawRabbit" so not to clash with other libraries
// that use LibLog
#if LIBLOG_PROVIDERS_ONLY
namespace RawRabbit.LibLog
#else
namespace RawRabbit.Logging
#endif
{
	using System.Collections.Generic;
	using System.Diagnostics.CodeAnalysis;
#if LIBLOG_PROVIDERS_ONLY
    using RawRabbit.LibLog.LogProviders;
#else
	using LogProviders;
#endif
	using System;
#if !LIBLOG_PROVIDERS_ONLY
	using System.Diagnostics;
#if !LIBLOG_PORTABLE
	using System.Runtime.CompilerServices;
#endif
#endif

#if LIBLOG_PROVIDERS_ONLY
    internal
#else
	public
#endif
		delegate bool Logger(LogLevel logLevel, Func<string> messageFunc, Exception exception = null, params object[] formatParameters);

#if !LIBLOG_PROVIDERS_ONLY
	/// <summary>
	/// Simple interface that represent a logger.
	/// </summary>
#if LIBLOG_PUBLIC
    public
#else
	internal
#endif
		interface ILog
	{
		/// <summary>
		/// Log a message the specified log level.
		/// </summary>
		/// <param name="logLevel">The log level.</param>
		/// <param name="messageFunc">The message function.</param>
		/// <param name="exception">An optional exception.</param>
		/// <param name="formatParameters">Optional format parameters for the message generated by the messagefunc. </param>
		/// <returns>true if the message was logged. Otherwise false.</returns>
		/// <remarks>
		/// Note to implementers: the message func should not be called if the loglevel is not enabled
		/// so as not to incur performance penalties.
		/// 
		/// To check IsEnabled call Log with only LogLevel and check the return value, no event will be written.
		/// </remarks>
		bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception = null, params object[] formatParameters);
	}
#endif

	/// <summary>
	/// The log level.
	/// </summary>
#if LIBLOG_PROVIDERS_ONLY
    internal
#else
	public
#endif
		enum LogLevel
	{
		Trace,
		Debug,
		Info,
		Warn,
		Error,
		Fatal
	}

#if !LIBLOG_PROVIDERS_ONLY
#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
#if LIBLOG_PUBLIC
    public
#else
	internal
#endif
		// ReSharper disable once PartialTypeWithSinglePart
		static partial class LogExtensions
	{
		public static bool IsDebugEnabled(this ILog logger)
		{
			GuardAgainstNullLogger(logger);
			return logger.Log(LogLevel.Debug, null);
		}

		public static bool IsErrorEnabled(this ILog logger)
		{
			GuardAgainstNullLogger(logger);
			return logger.Log(LogLevel.Error, null);
		}

		public static bool IsFatalEnabled(this ILog logger)
		{
			GuardAgainstNullLogger(logger);
			return logger.Log(LogLevel.Fatal, null);
		}

		public static bool IsInfoEnabled(this ILog logger)
		{
			GuardAgainstNullLogger(logger);
			return logger.Log(LogLevel.Info, null);
		}

		public static bool IsTraceEnabled(this ILog logger)
		{
			GuardAgainstNullLogger(logger);
			return logger.Log(LogLevel.Trace, null);
		}

		public static bool IsWarnEnabled(this ILog logger)
		{
			GuardAgainstNullLogger(logger);
			return logger.Log(LogLevel.Warn, null);
		}

		public static void Debug(this ILog logger, Func<string> messageFunc)
		{
			GuardAgainstNullLogger(logger);
			logger.Log(LogLevel.Debug, messageFunc);
		}

		public static void Debug(this ILog logger, string message)
		{
			if (logger.IsDebugEnabled())
			{
				logger.Log(LogLevel.Debug, message.AsFunc());
			}
		}

		public static void Debug(this ILog logger, string message, params object[] args)
		{
			logger.DebugFormat(message, args);
		}

		public static void Debug(this ILog logger, Exception exception, string message, params object[] args)
		{
			logger.DebugException(message, exception, args);
		}

		public static void DebugFormat(this ILog logger, string message, params object[] args)
		{
			if (logger.IsDebugEnabled())
			{
				logger.LogFormat(LogLevel.Debug, message, args);
			}
		}

		public static void DebugException(this ILog logger, string message, Exception exception)
		{
			if (logger.IsDebugEnabled())
			{
				logger.Log(LogLevel.Debug, message.AsFunc(), exception);
			}
		}

		public static void DebugException(this ILog logger, string message, Exception exception, params object[] formatParams)
		{
			if (logger.IsDebugEnabled())
			{
				logger.Log(LogLevel.Debug, message.AsFunc(), exception, formatParams);
			}
		}

		public static void Error(this ILog logger, Func<string> messageFunc)
		{
			GuardAgainstNullLogger(logger);
			logger.Log(LogLevel.Error, messageFunc);
		}

		public static void Error(this ILog logger, string message)
		{
			if (logger.IsErrorEnabled())
			{
				logger.Log(LogLevel.Error, message.AsFunc());
			}
		}

		public static void Error(this ILog logger, string message, params object[] args)
		{
			logger.ErrorFormat(message, args);
		}

		public static void Error(this ILog logger, Exception exception, string message, params object[] args)
		{
			logger.ErrorException(message, exception, args);
		}

		public static void ErrorFormat(this ILog logger, string message, params object[] args)
		{
			if (logger.IsErrorEnabled())
			{
				logger.LogFormat(LogLevel.Error, message, args);
			}
		}

		public static void ErrorException(this ILog logger, string message, Exception exception, params object[] formatParams)
		{
			if (logger.IsErrorEnabled())
			{
				logger.Log(LogLevel.Error, message.AsFunc(), exception, formatParams);
			}
		}

		public static void Fatal(this ILog logger, Func<string> messageFunc)
		{
			logger.Log(LogLevel.Fatal, messageFunc);
		}

		public static void Fatal(this ILog logger, string message)
		{
			if (logger.IsFatalEnabled())
			{
				logger.Log(LogLevel.Fatal, message.AsFunc());
			}
		}

		public static void Fatal(this ILog logger, string message, params object[] args)
		{
			logger.FatalFormat(message, args);
		}

		public static void Fatal(this ILog logger, Exception exception, string message, params object[] args)
		{
			logger.FatalException(message, exception, args);
		}

		public static void FatalFormat(this ILog logger, string message, params object[] args)
		{
			if (logger.IsFatalEnabled())
			{
				logger.LogFormat(LogLevel.Fatal, message, args);
			}
		}

		public static void FatalException(this ILog logger, string message, Exception exception, params object[] formatParams)
		{
			if (logger.IsFatalEnabled())
			{
				logger.Log(LogLevel.Fatal, message.AsFunc(), exception, formatParams);
			}
		}

		public static void Info(this ILog logger, Func<string> messageFunc)
		{
			GuardAgainstNullLogger(logger);
			logger.Log(LogLevel.Info, messageFunc);
		}

		public static void Info(this ILog logger, string message)
		{
			if (logger.IsInfoEnabled())
			{
				logger.Log(LogLevel.Info, message.AsFunc());
			}
		}

		public static void Info(this ILog logger, string message, params object[] args)
		{
			logger.InfoFormat(message, args);
		}

		public static void Info(this ILog logger, Exception exception, string message, params object[] args)
		{
			logger.InfoException(message, exception, args);
		}

		public static void InfoFormat(this ILog logger, string message, params object[] args)
		{
			if (logger.IsInfoEnabled())
			{
				logger.LogFormat(LogLevel.Info, message, args);
			}
		}

		public static void InfoException(this ILog logger, string message, Exception exception, params object[] formatParams)
		{
			if (logger.IsInfoEnabled())
			{
				logger.Log(LogLevel.Info, message.AsFunc(), exception, formatParams);
			}
		}

		public static void Trace(this ILog logger, Func<string> messageFunc)
		{
			GuardAgainstNullLogger(logger);
			logger.Log(LogLevel.Trace, messageFunc);
		}

		public static void Trace(this ILog logger, string message)
		{
			if (logger.IsTraceEnabled())
			{
				logger.Log(LogLevel.Trace, message.AsFunc());
			}
		}

		public static void Trace(this ILog logger, string message, params object[] args)
		{
			logger.TraceFormat(message, args);
		}

		public static void Trace(this ILog logger, Exception exception, string message, params object[] args)
		{
			logger.TraceException(message, exception, args);
		}

		public static void TraceFormat(this ILog logger, string message, params object[] args)
		{
			if (logger.IsTraceEnabled())
			{
				logger.LogFormat(LogLevel.Trace, message, args);
			}
		}

		public static void TraceException(this ILog logger, string message, Exception exception, params object[] formatParams)
		{
			if (logger.IsTraceEnabled())
			{
				logger.Log(LogLevel.Trace, message.AsFunc(), exception, formatParams);
			}
		}

		public static void Warn(this ILog logger, Func<string> messageFunc)
		{
			GuardAgainstNullLogger(logger);
			logger.Log(LogLevel.Warn, messageFunc);
		}

		public static void Warn(this ILog logger, string message)
		{
			if (logger.IsWarnEnabled())
			{
				logger.Log(LogLevel.Warn, message.AsFunc());
			}
		}

		public static void Warn(this ILog logger, string message, params object[] args)
		{
			logger.WarnFormat(message, args);
		}

		public static void Warn(this ILog logger, Exception exception, string message, params object[] args)
		{
			logger.WarnException(message, exception, args);
		}

		public static void WarnFormat(this ILog logger, string message, params object[] args)
		{
			if (logger.IsWarnEnabled())
			{
				logger.LogFormat(LogLevel.Warn, message, args);
			}
		}

		public static void WarnException(this ILog logger, string message, Exception exception, params object[] formatParams)
		{
			if (logger.IsWarnEnabled())
			{
				logger.Log(LogLevel.Warn, message.AsFunc(), exception, formatParams);
			}
		}

		// ReSharper disable once UnusedParameter.Local
		private static void GuardAgainstNullLogger(ILog logger)
		{
			if (logger == null)
			{
				throw new ArgumentNullException(nameof(logger));
			}
		}

		private static void LogFormat(this ILog logger, LogLevel logLevel, string message, params object[] args)
		{
			logger.Log(logLevel, message.AsFunc(), null, args);
		}

		// Avoid the closure allocation, see https://gist.github.com/AArnott/d285feef75c18f6ecd2b
		private static Func<T> AsFunc<T>(this T value) where T : class
		{
			return value.Return;
		}

		private static T Return<T>(this T value)
		{
			return value;
		}
	}
#endif

	/// <summary>
	/// Represents a way to get a <see cref="ILog"/>
	/// </summary>
#if LIBLOG_PROVIDERS_ONLY
    internal
#else
	public
#endif
		interface ILogProvider
	{
		/// <summary>
		/// Gets the specified named logger.
		/// </summary>
		/// <param name="name">Name of the logger.</param>
		/// <returns>The logger reference.</returns>
		Logger GetLogger(string name);

		/// <summary>
		/// Opens a nested diagnostics context. Not supported in EntLib logging.
		/// </summary>
		/// <param name="message">The message to add to the diagnostics context.</param>
		/// <returns>A disposable that when disposed removes the message from the context.</returns>
		IDisposable OpenNestedContext(string message);

		/// <summary>
		/// Opens a mapped diagnostics context. Not supported in EntLib logging.
		/// </summary>
		/// <param name="key">A key.</param>
		/// <param name="value">A value.</param>
		/// <returns>A disposable that when disposed removes the map from the context.</returns>
		IDisposable OpenMappedContext(string key, string value);
	}

	/// <summary>
	/// Provides a mechanism to create instances of <see cref="ILog" /> objects.
	/// </summary>
#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
#if LIBLOG_PROVIDERS_ONLY
    internal
#else
	public
#endif
		static class LogProvider
	{
#if !LIBLOG_PROVIDERS_ONLY
		private const string NullLogProvider = "Current Log Provider is not set. Call SetCurrentLogProvider " +
											   "with a non-null value first.";
		private static dynamic _sCurrentLogProvider;
		private static Action<ILogProvider> _sOnCurrentLogProviderSet;

		[SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
		static LogProvider()
		{
			IsDisabled = false;
		}

		/// <summary>
		/// Sets the current log provider.
		/// </summary>
		/// <param name="logProvider">The log provider.</param>
		public static void SetCurrentLogProvider(ILogProvider logProvider)
		{
			_sCurrentLogProvider = logProvider;

			RaiseOnCurrentLogProviderSet();
		}

		/// <summary>
		/// Gets or sets a value indicating whether this is logging is disabled.
		/// </summary>
		/// <value>
		/// <c>true</c> if logging is disabled; otherwise, <c>false</c>.
		/// </value>
		public static bool IsDisabled { get; set; }

		/// <summary>
		/// Sets an action that is invoked when a consumer of your library has called SetCurrentLogProvider. It is 
		/// important that hook into this if you are using child libraries (especially ilmerged ones) that are using
		/// LibLog (or other logging abstraction) so you adapt and delegate to them.
		/// <see cref="SetCurrentLogProvider"/> 
		/// </summary>
		internal static Action<ILogProvider> OnCurrentLogProviderSet
		{
			set
			{
				_sOnCurrentLogProviderSet = value;
				RaiseOnCurrentLogProviderSet();
			}
		}

		internal static ILogProvider CurrentLogProvider
		{
			get
			{
				return _sCurrentLogProvider;
			}
		}

		/// <summary>
		/// Gets a logger for the specified type.
		/// </summary>
		/// <typeparam name="T">The type whose name will be used for the logger.</typeparam>
		/// <returns>An instance of <see cref="ILog"/></returns>
#if LIBLOG_PUBLIC
        public
#else
		internal
#endif
			static ILog For<T>()
		{
			return GetLogger(typeof(T));
		}

#if !LIBLOG_PORTABLE
		/// <summary>
		/// Gets a logger for the current class.
		/// </summary>
		/// <returns>An instance of <see cref="ILog"/></returns>
		[MethodImpl(MethodImplOptions.NoInlining)]
#if LIBLOG_PUBLIC
        public
#else
		internal
#endif
			static ILog GetCurrentClassLogger()
		{
			var stackFrame = new StackFrame(1, false);
			return GetLogger(stackFrame.GetMethod().DeclaringType);
		}
#endif

		/// <summary>
		/// Gets a logger for the specified type.
		/// </summary>
		/// <param name="type">The type whose name will be used for the logger.</param>
		/// <param name="fallbackTypeName">If the type is null then this name will be used as the log name instead</param>
		/// <returns>An instance of <see cref="ILog"/></returns>
#if LIBLOG_PUBLIC
        public
#else
		internal
#endif
			static ILog GetLogger(Type type, string fallbackTypeName = "System.Object")
		{
			// If the type passed in is null then fallback to the type name specified
			return GetLogger(type != null ? type.FullName : fallbackTypeName);
		}

		/// <summary>
		/// Gets a logger with the specified name.
		/// </summary>
		/// <param name="name">The name.</param>
		/// <returns>An instance of <see cref="ILog"/></returns>
#if LIBLOG_PUBLIC
        public
#else
		internal
#endif
			static ILog GetLogger(string name)
		{
			ILogProvider logProvider = CurrentLogProvider ?? ResolveLogProvider();
			return logProvider == null
				? NoOpLogger.Instance
				: (ILog)new LoggerExecutionWrapper(logProvider.GetLogger(name), () => IsDisabled);
		}

		/// <summary>
		/// Opens a nested diagnostics context.
		/// </summary>
		/// <param name="message">A message.</param>
		/// <returns>An <see cref="IDisposable"/> that closes context when disposed.</returns>
		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "SetCurrentLogProvider")]
#if LIBLOG_PUBLIC
        public
#else
		internal
#endif
			static IDisposable OpenNestedContext(string message)
		{
			ILogProvider logProvider = CurrentLogProvider ?? ResolveLogProvider();

			return logProvider == null
				? new DisposableAction(() => { })
				: logProvider.OpenNestedContext(message);
		}

		/// <summary>
		/// Opens a mapped diagnostics context.
		/// </summary>
		/// <param name="key">A key.</param>
		/// <param name="value">A value.</param>
		/// <returns>An <see cref="IDisposable"/> that closes context when disposed.</returns>
		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "SetCurrentLogProvider")]
#if LIBLOG_PUBLIC
        public
#else
		internal
#endif
			static IDisposable OpenMappedContext(string key, string value)
		{
			ILogProvider logProvider = CurrentLogProvider ?? ResolveLogProvider();

			return logProvider == null
				? new DisposableAction(() => { })
				: logProvider.OpenMappedContext(key, value);
		}
#endif

#if LIBLOG_PROVIDERS_ONLY
    private
#else
		internal
#endif
			delegate bool IsLoggerAvailable();

#if LIBLOG_PROVIDERS_ONLY
    private
#else
		internal
#endif
			delegate ILogProvider CreateLogProvider();

#if LIBLOG_PROVIDERS_ONLY
    private
#else
		internal
#endif
			static readonly List<Tuple<IsLoggerAvailable, CreateLogProvider>> LogProviderResolvers =
				new()
				{
					new Tuple<IsLoggerAvailable, CreateLogProvider>(SerilogLogProvider.IsLoggerAvailable, () => new SerilogLogProvider()),
					new Tuple<IsLoggerAvailable, CreateLogProvider>(NLogLogProvider.IsLoggerAvailable, () => new NLogLogProvider()),
					new Tuple<IsLoggerAvailable, CreateLogProvider>(Log4NetLogProvider.IsLoggerAvailable, () => new Log4NetLogProvider()),
					new Tuple<IsLoggerAvailable, CreateLogProvider>(EntLibLogProvider.IsLoggerAvailable, () => new EntLibLogProvider()),
					new Tuple<IsLoggerAvailable, CreateLogProvider>(LoupeLogProvider.IsLoggerAvailable, () => new LoupeLogProvider()),
				};

#if !LIBLOG_PROVIDERS_ONLY
		private static void RaiseOnCurrentLogProviderSet()
		{
			if (_sOnCurrentLogProviderSet != null)
			{
				_sOnCurrentLogProviderSet(_sCurrentLogProvider);
			}
		}
#endif

		[SuppressMessage("Microsoft.Globalization", "CA1303:Do not pass literals as localized parameters", MessageId = "System.Console.WriteLine(System.String,System.Object,System.Object)")]
		[SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
		internal static ILogProvider ResolveLogProvider()
		{
			try
			{
				foreach (Tuple<IsLoggerAvailable, CreateLogProvider> providerResolver in LogProviderResolvers)
				{
					if (providerResolver.Item1())
					{
						return providerResolver.Item2();
					}
				}
			}
			catch (Exception ex)
			{
#if LIBLOG_PORTABLE
				Debug.WriteLine(
#else
				Console.WriteLine(
#endif
					"Exception occurred resolving a log provider. Logging for this assembly {0} is disabled. {1}",
					typeof(LogProvider).GetAssemblyPortable().FullName,
					ex);
			}
			return null;
		}

#if !LIBLOG_PROVIDERS_ONLY
#if !LIBLOG_PORTABLE
		[ExcludeFromCodeCoverage]
#endif
		internal class NoOpLogger : ILog
		{
			internal static readonly NoOpLogger Instance = new();

			public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception, params object[] formatParameters)
			{
				return false;
			}
		}
#endif
	}

#if !LIBLOG_PROVIDERS_ONLY
#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class LoggerExecutionWrapper : ILog
	{
		private readonly Func<bool> _getIsDisabled;
		internal const string FailedToGenerateLogMessage = "Failed to generate log message";

		internal LoggerExecutionWrapper(Logger logger, Func<bool> getIsDisabled = null)
		{
			this.WrappedLogger = logger;
			this._getIsDisabled = getIsDisabled ?? (() => false);
		}

		internal Logger WrappedLogger { get; }

		[SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
		public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception = null, params object[] formatParameters)
		{
			if (this._getIsDisabled())
			{
				return false;
			}
			if (messageFunc == null)
			{
				return this.WrappedLogger(logLevel, null);
			}

			Func<string> wrappedMessageFunc = () =>
			{
				try
				{
					return messageFunc();
				}
				catch (Exception ex)
				{
					this.Log(LogLevel.Error, () => FailedToGenerateLogMessage, ex);
				}
				return null;
			};
			return this.WrappedLogger(logLevel, wrappedMessageFunc, exception, formatParameters);
		}
	}
#endif
}

#if LIBLOG_PROVIDERS_ONLY
namespace RawRabbit.LibLog.LogProviders
#else
namespace RawRabbit.Logging.LogProviders
#endif
{
	using System;
	using System.Collections.Generic;
	using System.Diagnostics.CodeAnalysis;
#if !LIBLOG_PORTABLE
	using System.Diagnostics;
#endif
	using System.Globalization;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
#if !LIBLOG_PORTABLE
	using System.Text;
#endif
	using System.Text.RegularExpressions;

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal abstract class LogProviderBase : ILogProvider
	{
		protected delegate IDisposable OpenNdc(string message);
		protected delegate IDisposable OpenMdc(string key, string value);

		private readonly Lazy<OpenNdc> _lazyOpenNdcMethod;
		private readonly Lazy<OpenMdc> _lazyOpenMdcMethod;
		private static readonly IDisposable _noopDisposableInstance = new DisposableAction();

		protected LogProviderBase()
		{
			this._lazyOpenNdcMethod
				= new Lazy<OpenNdc>(this.GetOpenNdcMethod);
			this._lazyOpenMdcMethod
				= new Lazy<OpenMdc>(this.GetOpenMdcMethod);
		}

		public abstract Logger GetLogger(string name);

		public IDisposable OpenNestedContext(string message)
		{
			return this._lazyOpenNdcMethod.Value(message);
		}

		public IDisposable OpenMappedContext(string key, string value)
		{
			return this._lazyOpenMdcMethod.Value(key, value);
		}

		protected virtual OpenNdc GetOpenNdcMethod()
		{
			return _ => _noopDisposableInstance;
		}

		protected virtual OpenMdc GetOpenMdcMethod()
		{
			return (_, __) => _noopDisposableInstance;
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class NLogLogProvider : LogProviderBase
	{
		private readonly Func<string, object> _getLoggerByNameDelegate;

		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "LogManager")]
		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "NLog")]
		public NLogLogProvider()
		{
			if (!IsLoggerAvailable())
			{
				throw new InvalidOperationException("NLog.LogManager not found");
			}

			this._getLoggerByNameDelegate = GetGetLoggerMethodCall();
		}

		public static bool ProviderIsAvailableOverride { get; set; } = true;

		public override Logger GetLogger(string name)
		{
			return new NLogLogger(this._getLoggerByNameDelegate(name)).Log;
		}

		public static bool IsLoggerAvailable()
		{
			return ProviderIsAvailableOverride && GetLogManagerType() != null;
		}

		protected override OpenNdc GetOpenNdcMethod()
		{
			Type ndcContextType = Type.GetType("NLog.NestedDiagnosticsContext, NLog");
			MethodInfo pushMethod = ndcContextType.GetMethodPortable("Push", typeof(string));
			ParameterExpression messageParam = Expression.Parameter(typeof(string), "message");
			MethodCallExpression pushMethodCall = Expression.Call(null, pushMethod, messageParam);
			return Expression.Lambda<OpenNdc>(pushMethodCall, messageParam).Compile();
		}

		protected override OpenMdc GetOpenMdcMethod()
		{
			Type mdcContextType = Type.GetType("NLog.MappedDiagnosticsContext, NLog");

			MethodInfo setMethod = mdcContextType.GetMethodPortable("Set", typeof(string), typeof(string));
			MethodInfo removeMethod = mdcContextType.GetMethodPortable("Remove", typeof(string));
			ParameterExpression keyParam = Expression.Parameter(typeof(string), "key");
			ParameterExpression valueParam = Expression.Parameter(typeof(string), "value");

			MethodCallExpression setMethodCall = Expression.Call(null, setMethod, keyParam, valueParam);
			MethodCallExpression removeMethodCall = Expression.Call(null, removeMethod, keyParam);

			Action<string, string> set = Expression
				.Lambda<Action<string, string>>(setMethodCall, keyParam, valueParam)
				.Compile();
			Action<string> remove = Expression
				.Lambda<Action<string>>(removeMethodCall, keyParam)
				.Compile();

			return (key, value) =>
			{
				set(key, value);
				return new DisposableAction(() => remove(key));
			};
		}

		private static Type GetLogManagerType()
		{
			return Type.GetType("NLog.LogManager, NLog");
		}

		private static Func<string, object> GetGetLoggerMethodCall()
		{
			Type logManagerType = GetLogManagerType();
			MethodInfo method = logManagerType.GetMethodPortable("GetLogger", typeof(string));
			ParameterExpression nameParam = Expression.Parameter(typeof(string), "name");
			MethodCallExpression methodCall = Expression.Call(null, method, nameParam);
			return Expression.Lambda<Func<string, object>>(methodCall, nameParam).Compile();
		}

#if !LIBLOG_PORTABLE
		[ExcludeFromCodeCoverage]
#endif
		internal class NLogLogger
		{
			private readonly dynamic _logger;

			private static Func<string, object, string, Exception, object> _logEventInfoFact;

			private static readonly object _levelTrace;
			private static readonly object _levelDebug;
			private static readonly object _levelInfo;
			private static readonly object _levelWarn;
			private static readonly object _levelError;
			private static readonly object _levelFatal;

			// ReSharper disable once FunctionComplexityOverflow
			static NLogLogger()
			{
				try
				{
					Type logEventLevelType = Type.GetType("NLog.LogLevel, NLog");
					if (logEventLevelType == null)
					{
						throw new InvalidOperationException("Type NLog.LogLevel was not found.");
					}

					List<FieldInfo> levelFields = logEventLevelType.GetFieldsPortable().ToList();
					_levelTrace = levelFields.First(x => x.Name == "Trace").GetValue(null);
					_levelDebug = levelFields.First(x => x.Name == "Debug").GetValue(null);
					_levelInfo = levelFields.First(x => x.Name == "Info").GetValue(null);
					_levelWarn = levelFields.First(x => x.Name == "Warn").GetValue(null);
					_levelError = levelFields.First(x => x.Name == "Error").GetValue(null);
					_levelFatal = levelFields.First(x => x.Name == "Fatal").GetValue(null);

					Type logEventInfoType = Type.GetType("NLog.LogEventInfo, NLog");
					if (logEventInfoType == null)
					{
						throw new InvalidOperationException("Type NLog.LogEventInfo was not found.");
					}
					MethodInfo createLogEventInfoMethodInfo = logEventInfoType.GetMethodPortable("Create",
						logEventLevelType, typeof(string), typeof(Exception), typeof(IFormatProvider), typeof(string), typeof(object[]));
					ParameterExpression loggerNameParam = Expression.Parameter(typeof(string));
					ParameterExpression levelParam = Expression.Parameter(typeof(object));
					ParameterExpression messageParam = Expression.Parameter(typeof(string));
					ParameterExpression exceptionParam = Expression.Parameter(typeof(Exception));
					UnaryExpression levelCast = Expression.Convert(levelParam, logEventLevelType);
					MethodCallExpression createLogEventInfoMethodCall = Expression.Call(null,
						createLogEventInfoMethodInfo,
						levelCast, loggerNameParam, exceptionParam,
						Expression.Constant(null, typeof(IFormatProvider)), messageParam, Expression.Constant(null, typeof(object[])));
					_logEventInfoFact = Expression.Lambda<Func<string, object, string, Exception, object>>(createLogEventInfoMethodCall,
						loggerNameParam, levelParam, messageParam, exceptionParam).Compile();
				}
				catch
				{
					// ignored
				}
			}

			internal NLogLogger(dynamic logger)
			{
				this._logger = logger;
			}

			[SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
			[SuppressMessage("ReSharper", "ConditionIsAlwaysTrueOrFalse")]
			[SuppressMessage("ReSharper", "HeuristicUnreachableCode")]
			public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception, params object[] formatParameters)
			{
				if (messageFunc == null)
				{
					return this.IsLogLevelEnable(logLevel);
				}
				messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters);

				if (_logEventInfoFact != null)
				{
					if (this.IsLogLevelEnable(logLevel))
					{
						object nlogLevel = this.TranslateLevel(logLevel);
#if !LIBLOG_PORTABLE
						StackTrace stack = new StackTrace();
						Type thisType = GetType();
						Type knownType0 = typeof(LoggerExecutionWrapper);
						Type knownType1 = typeof(LogExtensions);
						//Maybe inline, so we may can't found any LibLog classes in stack
						s_callerStackBoundaryType = null;
						for (var i = 0; i < stack.FrameCount; i++)
						{
							var declaringType = stack.GetFrame(i).GetMethod().DeclaringType;
							if (!IsInTypeHierarchy(thisType, declaringType) &&
								!IsInTypeHierarchy(knownType0, declaringType) &&
								!IsInTypeHierarchy(knownType1, declaringType))
							{
								if (i > 1)
									s_callerStackBoundaryType = stack.GetFrame(i - 1).GetMethod().DeclaringType;
								break;
							}
						}
#else
						Type sCallerStackBoundaryType = null;
#endif
						//TODO NULL Object
						if (sCallerStackBoundaryType != null)
							this._logger.Log(sCallerStackBoundaryType, _logEventInfoFact(this._logger.Name, nlogLevel, messageFunc(), exception));
						else
							this._logger.Log(_logEventInfoFact(this._logger.Name, nlogLevel, messageFunc(), exception));
						return true;
					}
					return false;
				}

				if (exception != null)
				{
					return this.LogException(logLevel, messageFunc, exception);
				}
				switch (logLevel)
				{
					case LogLevel.Debug:
						if (this._logger.IsDebugEnabled)
						{
							this._logger.Debug(messageFunc());
							return true;
						}
						break;
					case LogLevel.Info:
						if (this._logger.IsInfoEnabled)
						{
							this._logger.Info(messageFunc());
							return true;
						}
						break;
					case LogLevel.Warn:
						if (this._logger.IsWarnEnabled)
						{
							this._logger.Warn(messageFunc());
							return true;
						}
						break;
					case LogLevel.Error:
						if (this._logger.IsErrorEnabled)
						{
							this._logger.Error(messageFunc());
							return true;
						}
						break;
					case LogLevel.Fatal:
						if (this._logger.IsFatalEnabled)
						{
							this._logger.Fatal(messageFunc());
							return true;
						}
						break;
					default:
						if (this._logger.IsTraceEnabled)
						{
							this._logger.Trace(messageFunc());
							return true;
						}
						break;
				}
				return false;
			}

			private static bool IsInTypeHierarchy(Type currentType, Type checkType)
			{
				while (currentType != null && currentType != typeof(object))
				{
					if (currentType == checkType)
					{
						return true;
					}
					currentType = currentType.GetBaseTypePortable();
				}
				return false;
			}

			[SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
			private bool LogException(LogLevel logLevel, Func<string> messageFunc, Exception exception)
			{
				switch (logLevel)
				{
					case LogLevel.Debug:
						if (this._logger.IsDebugEnabled)
						{
							this._logger.DebugException(messageFunc(), exception);
							return true;
						}
						break;
					case LogLevel.Info:
						if (this._logger.IsInfoEnabled)
						{
							this._logger.InfoException(messageFunc(), exception);
							return true;
						}
						break;
					case LogLevel.Warn:
						if (this._logger.IsWarnEnabled)
						{
							this._logger.WarnException(messageFunc(), exception);
							return true;
						}
						break;
					case LogLevel.Error:
						if (this._logger.IsErrorEnabled)
						{
							this._logger.ErrorException(messageFunc(), exception);
							return true;
						}
						break;
					case LogLevel.Fatal:
						if (this._logger.IsFatalEnabled)
						{
							this._logger.FatalException(messageFunc(), exception);
							return true;
						}
						break;
					default:
						if (this._logger.IsTraceEnabled)
						{
							this._logger.TraceException(messageFunc(), exception);
							return true;
						}
						break;
				}
				return false;
			}

			private bool IsLogLevelEnable(LogLevel logLevel)
			{
				switch (logLevel)
				{
					case LogLevel.Debug:
						return this._logger.IsDebugEnabled;
					case LogLevel.Info:
						return this._logger.IsInfoEnabled;
					case LogLevel.Warn:
						return this._logger.IsWarnEnabled;
					case LogLevel.Error:
						return this._logger.IsErrorEnabled;
					case LogLevel.Fatal:
						return this._logger.IsFatalEnabled;
					default:
						return this._logger.IsTraceEnabled;
				}
			}

			private object TranslateLevel(LogLevel logLevel)
			{
				switch (logLevel)
				{
					case LogLevel.Trace:
						return _levelTrace;
					case LogLevel.Debug:
						return _levelDebug;
					case LogLevel.Info:
						return _levelInfo;
					case LogLevel.Warn:
						return _levelWarn;
					case LogLevel.Error:
						return _levelError;
					case LogLevel.Fatal:
						return _levelFatal;
					default:
						throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null);
				}
			}
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class Log4NetLogProvider : LogProviderBase
	{
		private readonly Func<string, object> _getLoggerByNameDelegate;

		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "LogManager")]
		public Log4NetLogProvider()
		{
			if (!IsLoggerAvailable())
			{
				throw new InvalidOperationException("log4net.LogManager not found");
			}

			this._getLoggerByNameDelegate = GetGetLoggerMethodCall();
		}

		public static bool ProviderIsAvailableOverride { get; set; } = true;

		public override Logger GetLogger(string name)
		{
			return new Log4NetLogger(this._getLoggerByNameDelegate(name)).Log;
		}

		internal static bool IsLoggerAvailable()
		{
			return ProviderIsAvailableOverride && GetLogManagerType() != null;
		}

		protected override OpenNdc GetOpenNdcMethod()
		{
			Type logicalThreadContextType = Type.GetType("log4net.LogicalThreadContext, log4net");
			PropertyInfo stacksProperty = logicalThreadContextType.GetPropertyPortable("Stacks");
			Type logicalThreadContextStacksType = stacksProperty.PropertyType;
			PropertyInfo stacksIndexerProperty = logicalThreadContextStacksType.GetPropertyPortable("Item");
			Type stackType = stacksIndexerProperty.PropertyType;
			MethodInfo pushMethod = stackType.GetMethodPortable("Push");

			ParameterExpression messageParameter =
				Expression.Parameter(typeof(string), "message");

			// message => LogicalThreadContext.Stacks.Item["NDC"].Push(message);
			MethodCallExpression callPushBody =
				Expression.Call(
					Expression.Property(Expression.Property(null, stacksProperty),
						stacksIndexerProperty,
						Expression.Constant("NDC")),
					pushMethod,
					messageParameter);

			OpenNdc result =
				Expression.Lambda<OpenNdc>(callPushBody, messageParameter)
					.Compile();

			return result;
		}

		protected override OpenMdc GetOpenMdcMethod()
		{
			Type logicalThreadContextType = Type.GetType("log4net.LogicalThreadContext, log4net");
			PropertyInfo propertiesProperty = logicalThreadContextType.GetPropertyPortable("Properties");
			Type logicalThreadContextPropertiesType = propertiesProperty.PropertyType;
			PropertyInfo propertiesIndexerProperty = logicalThreadContextPropertiesType.GetPropertyPortable("Item");

			MethodInfo removeMethod = logicalThreadContextPropertiesType.GetMethodPortable("Remove");

			ParameterExpression keyParam = Expression.Parameter(typeof(string), "key");
			ParameterExpression valueParam = Expression.Parameter(typeof(string), "value");

			MemberExpression propertiesExpression = Expression.Property(null, propertiesProperty);

			// (key, value) => LogicalThreadContext.Properties.Item[key] = value;
			BinaryExpression setProperties = Expression.Assign(Expression.Property(propertiesExpression, propertiesIndexerProperty, keyParam), valueParam);

			// key => LogicalThreadContext.Properties.Remove(key);
			MethodCallExpression removeMethodCall = Expression.Call(propertiesExpression, removeMethod, keyParam);

			Action<string, string> set = Expression
				.Lambda<Action<string, string>>(setProperties, keyParam, valueParam)
				.Compile();

			Action<string> remove = Expression
				.Lambda<Action<string>>(removeMethodCall, keyParam)
				.Compile();

			return (key, value) =>
			{
				set(key, value);
				return new DisposableAction(() => remove(key));
			};
		}

		private static Type GetLogManagerType()
		{
			return Type.GetType("log4net.LogManager, log4net");
		}

		private static Func<string, object> GetGetLoggerMethodCall()
		{
			Type logManagerType = GetLogManagerType();
			MethodInfo method = logManagerType.GetMethodPortable("GetLogger", typeof(string));
			ParameterExpression nameParam = Expression.Parameter(typeof(string), "name");
			MethodCallExpression methodCall = Expression.Call(null, method, nameParam);
			return Expression.Lambda<Func<string, object>>(methodCall, nameParam).Compile();
		}

#if !LIBLOG_PORTABLE
		[ExcludeFromCodeCoverage]
#endif
		internal class Log4NetLogger
		{
			private readonly dynamic _logger;
			private static Type _sCallerStackBoundaryType;
			private static readonly object _callerStackBoundaryTypeSync = new();

			private readonly object _levelDebug;
			private readonly object _levelInfo;
			private readonly object _levelWarn;
			private readonly object _levelError;
			private readonly object _levelFatal;
			private readonly Func<object, object, bool> _isEnabledForDelegate;
			private readonly Action<object, object> _logDelegate;
			private readonly Func<object, Type, object, string, Exception, object> _createLoggingEvent;
			private Action<object, string, object> _loggingEventPropertySetter;

			[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "ILogger")]
			internal Log4NetLogger(dynamic logger)
			{
				this._logger = logger.Logger;

				Type logEventLevelType = Type.GetType("log4net.Core.Level, log4net");
				if (logEventLevelType == null)
				{
					throw new InvalidOperationException("Type log4net.Core.Level was not found.");
				}

				List<FieldInfo> levelFields = logEventLevelType.GetFieldsPortable().ToList();
				this._levelDebug = levelFields.First(x => x.Name == "Debug").GetValue(null);
				this._levelInfo = levelFields.First(x => x.Name == "Info").GetValue(null);
				this._levelWarn = levelFields.First(x => x.Name == "Warn").GetValue(null);
				this._levelError = levelFields.First(x => x.Name == "Error").GetValue(null);
				this._levelFatal = levelFields.First(x => x.Name == "Fatal").GetValue(null);

				// Func<object, object, bool> isEnabledFor = (logger, level) => { return ((log4net.Core.ILogger)logger).IsEnabled(level); }
				Type loggerType = Type.GetType("log4net.Core.ILogger, log4net");
				if (loggerType == null)
				{
					throw new InvalidOperationException("Type log4net.Core.ILogger, was not found.");
				}
				ParameterExpression instanceParam = Expression.Parameter(typeof(object));
				UnaryExpression instanceCast = Expression.Convert(instanceParam, loggerType);
				ParameterExpression levelParam = Expression.Parameter(typeof(object));
				UnaryExpression levelCast = Expression.Convert(levelParam, logEventLevelType);
				this._isEnabledForDelegate = GetIsEnabledFor(loggerType, logEventLevelType, instanceCast, levelCast, instanceParam, levelParam);

				Type loggingEventType = Type.GetType("log4net.Core.LoggingEvent, log4net");

				this._createLoggingEvent = GetCreateLoggingEvent(instanceParam, instanceCast, levelParam, levelCast, loggingEventType);

				this._logDelegate = GetLogDelegate(loggerType, loggingEventType, instanceCast, instanceParam);

				this._loggingEventPropertySetter = GetLoggingEventPropertySetter(loggingEventType);
			}

			private static Action<object, object> GetLogDelegate(Type loggerType, Type loggingEventType, UnaryExpression instanceCast,
				ParameterExpression instanceParam)
			{
				//Action<object, object, string, Exception> Log =
				//(logger, callerStackBoundaryDeclaringType, level, message, exception) => { ((ILogger)logger).Log(new LoggingEvent(callerStackBoundaryDeclaringType, logger.Repository, logger.Name, level, message, exception)); }
				MethodInfo writeExceptionMethodInfo = loggerType.GetMethodPortable("Log",
					loggingEventType);

				ParameterExpression loggingEventParameter =
					Expression.Parameter(typeof(object), "loggingEvent");

				UnaryExpression loggingEventCasted =
					Expression.Convert(loggingEventParameter, loggingEventType);

				MethodCallExpression writeMethodExp = Expression.Call(
					instanceCast,
					writeExceptionMethodInfo,
					loggingEventCasted);

				Action<object, object> logDelegate = Expression.Lambda<Action<object, object>>(
					writeMethodExp,
					instanceParam,
					loggingEventParameter).Compile();

				return logDelegate;
			}

			private static Func<object, Type, object, string, Exception, object> GetCreateLoggingEvent(ParameterExpression instanceParam, UnaryExpression instanceCast, ParameterExpression levelParam, UnaryExpression levelCast, Type loggingEventType)
			{
				ParameterExpression callerStackBoundaryDeclaringTypeParam = Expression.Parameter(typeof(Type));
				ParameterExpression messageParam = Expression.Parameter(typeof(string));
				ParameterExpression exceptionParam = Expression.Parameter(typeof(Exception));

				PropertyInfo repositoryProperty = loggingEventType.GetPropertyPortable("Repository");
				PropertyInfo levelProperty = loggingEventType.GetPropertyPortable("Level");

				ConstructorInfo loggingEventConstructor =
					loggingEventType.GetConstructorPortable(typeof(Type), repositoryProperty.PropertyType, typeof(string), levelProperty.PropertyType, typeof(object), typeof(Exception));

				//Func<object, object, string, Exception, object> Log =
				//(logger, callerStackBoundaryDeclaringType, level, message, exception) => new LoggingEvent(callerStackBoundaryDeclaringType, ((ILogger)logger).Repository, ((ILogger)logger).Name, (Level)level, message, exception); }
				NewExpression newLoggingEventExpression =
					Expression.New(loggingEventConstructor,
						callerStackBoundaryDeclaringTypeParam,
						Expression.Property(instanceCast, "Repository"),
						Expression.Property(instanceCast, "Name"),
						levelCast,
						messageParam,
						exceptionParam);

				Func<object, Type, object, string, Exception, object> createLoggingEvent =
					Expression.Lambda<Func<object, Type, object, string, Exception, object>>(
							newLoggingEventExpression,
							instanceParam,
							callerStackBoundaryDeclaringTypeParam,
							levelParam,
							messageParam,
							exceptionParam)
						.Compile();

				return createLoggingEvent;
			}

			private static Func<object, object, bool> GetIsEnabledFor(Type loggerType, Type logEventLevelType,
				UnaryExpression instanceCast,
				UnaryExpression levelCast,
				ParameterExpression instanceParam,
				ParameterExpression levelParam)
			{
				MethodInfo isEnabledMethodInfo = loggerType.GetMethodPortable("IsEnabledFor", logEventLevelType);
				MethodCallExpression isEnabledMethodCall = Expression.Call(instanceCast, isEnabledMethodInfo, levelCast);

				Func<object, object, bool> result =
					Expression.Lambda<Func<object, object, bool>>(isEnabledMethodCall, instanceParam, levelParam)
						.Compile();

				return result;
			}

			private static Action<object, string, object> GetLoggingEventPropertySetter(Type loggingEventType)
			{
				ParameterExpression loggingEventParameter = Expression.Parameter(typeof(object), "loggingEvent");
				ParameterExpression keyParameter = Expression.Parameter(typeof(string), "key");
				ParameterExpression valueParameter = Expression.Parameter(typeof(object), "value");

				PropertyInfo propertiesProperty = loggingEventType.GetPropertyPortable("Properties");
				PropertyInfo item = propertiesProperty.PropertyType.GetPropertyPortable("Item");

				// ((LoggingEvent)loggingEvent).Properties[key] = value;
				BinaryExpression body =
					Expression.Assign(
						Expression.Property(
							Expression.Property(Expression.Convert(loggingEventParameter, loggingEventType),
								propertiesProperty), item, keyParameter), valueParameter);

				Action<object, string, object> result =
					Expression.Lambda<Action<object, string, object>>
						(body, loggingEventParameter, keyParameter,
							valueParameter)
						.Compile();

				return result;
			}

			public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception, params object[] formatParameters)
			{
				if (messageFunc == null)
				{
					return this.IsLogLevelEnable(logLevel);
				}

				if (!this.IsLogLevelEnable(logLevel))
				{
					return false;
				}

				string message = messageFunc();

				IEnumerable<string> patternMatches;

				string formattedMessage =
					LogMessageFormatter.FormatStructuredMessage(message,
						formatParameters,
						out patternMatches);

				// determine correct caller - this might change due to jit optimizations with method inlining
				if (_sCallerStackBoundaryType == null)
				{
					lock (_callerStackBoundaryTypeSync)
					{
#if !LIBLOG_PORTABLE
						StackTrace stack = new StackTrace();
						Type thisType = GetType();
						s_callerStackBoundaryType = Type.GetType("LoggerExecutionWrapper");
						for (var i = 1; i < stack.FrameCount; i++)
						{
							if (!IsInTypeHierarchy(thisType, stack.GetFrame(i).GetMethod().DeclaringType))
							{
								s_callerStackBoundaryType = stack.GetFrame(i - 1).GetMethod().DeclaringType;
								break;
							}
						}
#else
						_sCallerStackBoundaryType = typeof(LoggerExecutionWrapper);
#endif
					}
				}

				object translatedLevel = this.TranslateLevel(logLevel);

				object loggingEvent = this._createLoggingEvent(this._logger, _sCallerStackBoundaryType, translatedLevel, formattedMessage, exception);

				this.PopulateProperties(loggingEvent, patternMatches, formatParameters);

				this._logDelegate(this._logger, loggingEvent);

				return true;
			}

			private void PopulateProperties(object loggingEvent, IEnumerable<string> patternMatches, IEnumerable<object> formatParameters)
			{
				IEnumerable<KeyValuePair<string, object>> keyToValue =
					patternMatches.Zip(formatParameters,
						(key, value) => new KeyValuePair<string, object>(key, value));

				foreach (KeyValuePair<string, object> keyValuePair in keyToValue)
				{
					this._loggingEventPropertySetter(loggingEvent, keyValuePair.Key, keyValuePair.Value);
				}
			}

			private static bool IsInTypeHierarchy(Type currentType, Type checkType)
			{
				while (currentType != null && currentType != typeof(object))
				{
					if (currentType == checkType)
					{
						return true;
					}
					currentType = currentType.GetBaseTypePortable();
				}
				return false;
			}

			private bool IsLogLevelEnable(LogLevel logLevel)
			{
				object level = this.TranslateLevel(logLevel);
				return this._isEnabledForDelegate(this._logger, level);
			}

			private object TranslateLevel(LogLevel logLevel)
			{
				switch (logLevel)
				{
					case LogLevel.Trace:
					case LogLevel.Debug:
						return this._levelDebug;
					case LogLevel.Info:
						return this._levelInfo;
					case LogLevel.Warn:
						return this._levelWarn;
					case LogLevel.Error:
						return this._levelError;
					case LogLevel.Fatal:
						return this._levelFatal;
					default:
						throw new ArgumentOutOfRangeException(nameof(logLevel), logLevel, null);
				}
			}
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class EntLibLogProvider : LogProviderBase
	{
		private const string TypeTemplate = "Microsoft.Practices.EnterpriseLibrary.Logging.{0}, Microsoft.Practices.EnterpriseLibrary.Logging";
		private static readonly Type _logEntryType;
		private static readonly Type _loggerType;
		private static readonly Type _traceEventTypeType;
		private static readonly Action<string, string, int> _writeLogEntry;
		private static readonly Func<string, int, bool> _shouldLogEntry;

		[SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
		static EntLibLogProvider()
		{
			_logEntryType = Type.GetType(string.Format(CultureInfo.InvariantCulture, TypeTemplate, "LogEntry"));
			_loggerType = Type.GetType(string.Format(CultureInfo.InvariantCulture, TypeTemplate, "Logger"));
			_traceEventTypeType = TraceEventTypeValues.Type;
			if (_logEntryType == null
				|| _traceEventTypeType == null
				|| _loggerType == null)
			{
				return;
			}
			_writeLogEntry = GetWriteLogEntry();
			_shouldLogEntry = GetShouldLogEntry();
		}

		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "EnterpriseLibrary")]
		public EntLibLogProvider()
		{
			if (!IsLoggerAvailable())
			{
				throw new InvalidOperationException("Microsoft.Practices.EnterpriseLibrary.Logging.Logger not found");
			}
		}

		public static bool ProviderIsAvailableOverride { get; set; } = true;

		public override Logger GetLogger(string name)
		{
			return new EntLibLogger(name, _writeLogEntry, _shouldLogEntry).Log;
		}

		internal static bool IsLoggerAvailable()
		{
			return ProviderIsAvailableOverride
				   && _traceEventTypeType != null
				   && _logEntryType != null;
		}

		private static Action<string, string, int> GetWriteLogEntry()
		{
			// new LogEntry(...)
			ParameterExpression logNameParameter = Expression.Parameter(typeof(string), "logName");
			ParameterExpression messageParameter = Expression.Parameter(typeof(string), "message");
			ParameterExpression severityParameter = Expression.Parameter(typeof(int), "severity");

			MemberInitExpression memberInit = GetWriteLogExpression(
				messageParameter,
				Expression.Convert(severityParameter, _traceEventTypeType),
				logNameParameter);

			//Logger.Write(new LogEntry(....));
			MethodInfo writeLogEntryMethod = _loggerType.GetMethodPortable("Write", _logEntryType);
			MethodCallExpression writeLogEntryExpression = Expression.Call(writeLogEntryMethod, memberInit);

			return Expression.Lambda<Action<string, string, int>>(
				writeLogEntryExpression,
				logNameParameter,
				messageParameter,
				severityParameter).Compile();
		}

		private static Func<string, int, bool> GetShouldLogEntry()
		{
			// new LogEntry(...)
			ParameterExpression logNameParameter = Expression.Parameter(typeof(string), "logName");
			ParameterExpression severityParameter = Expression.Parameter(typeof(int), "severity");

			MemberInitExpression memberInit = GetWriteLogExpression(
				Expression.Constant("***dummy***"),
				Expression.Convert(severityParameter, _traceEventTypeType),
				logNameParameter);

			//Logger.Write(new LogEntry(....));
			MethodInfo writeLogEntryMethod = _loggerType.GetMethodPortable("ShouldLog", _logEntryType);
			MethodCallExpression writeLogEntryExpression = Expression.Call(writeLogEntryMethod, memberInit);

			return Expression.Lambda<Func<string, int, bool>>(
				writeLogEntryExpression,
				logNameParameter,
				severityParameter).Compile();
		}

		private static MemberInitExpression GetWriteLogExpression(Expression message,
			Expression severityParameter, ParameterExpression logNameParameter)
		{
			Type entryType = _logEntryType;
			MemberInitExpression memberInit = Expression.MemberInit(Expression.New(entryType),
				Expression.Bind(entryType.GetPropertyPortable("Message"), message),
				Expression.Bind(entryType.GetPropertyPortable("Severity"), severityParameter),
				Expression.Bind(
					entryType.GetPropertyPortable("TimeStamp"),
					Expression.Property(null, typeof(DateTime).GetPropertyPortable("UtcNow"))),
				Expression.Bind(
					entryType.GetPropertyPortable("Categories"),
					Expression.ListInit(
						Expression.New(typeof(List<string>)),
						typeof(List<string>).GetMethodPortable("Add", typeof(string)),
						logNameParameter)));
			return memberInit;
		}

#if !LIBLOG_PORTABLE
		[ExcludeFromCodeCoverage]
#endif
		internal class EntLibLogger
		{
			private readonly string _loggerName;
			private readonly Action<string, string, int> _writeLog;
			private readonly Func<string, int, bool> _shouldLog;

			internal EntLibLogger(string loggerName, Action<string, string, int> writeLog, Func<string, int, bool> shouldLog)
			{
				this._loggerName = loggerName;
				this._writeLog = writeLog;
				this._shouldLog = shouldLog;
			}

			public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception, params object[] formatParameters)
			{
				int severity = MapSeverity(logLevel);
				if (messageFunc == null)
				{
					return this._shouldLog(this._loggerName, severity);
				}


				messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters);
				if (exception != null)
				{
					return this.LogException(logLevel, messageFunc, exception);
				}

				this._writeLog(this._loggerName, messageFunc(), severity);
				return true;
			}

			public bool LogException(LogLevel logLevel, Func<string> messageFunc, Exception exception)
			{
				int severity = MapSeverity(logLevel);
				string message = messageFunc() + Environment.NewLine + exception;
				this._writeLog(this._loggerName, message, severity);
				return true;
			}

			private static int MapSeverity(LogLevel logLevel)
			{
				switch (logLevel)
				{
					case LogLevel.Fatal:
						return TraceEventTypeValues.Critical;
					case LogLevel.Error:
						return TraceEventTypeValues.Error;
					case LogLevel.Warn:
						return TraceEventTypeValues.Warning;
					case LogLevel.Info:
						return TraceEventTypeValues.Information;
					default:
						return TraceEventTypeValues.Verbose;
				}
			}
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class SerilogLogProvider : LogProviderBase
	{
		private readonly Func<string, object> _getLoggerByNameDelegate;

		[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "Serilog")]
		public SerilogLogProvider()
		{
			if (!IsLoggerAvailable())
			{
				throw new InvalidOperationException("Serilog.Log not found");
			}

			this._getLoggerByNameDelegate = GetForContextMethodCall();
		}

		public static bool ProviderIsAvailableOverride { get; set; } = true;

		public override Logger GetLogger(string name)
		{
			return new SerilogLogger(this._getLoggerByNameDelegate(name)).Log;
		}

		internal static bool IsLoggerAvailable()
		{
			return ProviderIsAvailableOverride && GetLogManagerType() != null;
		}

		protected override OpenNdc GetOpenNdcMethod()
		{
			return message => GetPushProperty()("NDC", message);
		}

		protected override OpenMdc GetOpenMdcMethod()
		{
			return (key, value) => GetPushProperty()(key, value);
		}

		private static Func<string, string, IDisposable> GetPushProperty()
		{
			Type ndcContextType = Type.GetType("Serilog.Context.LogContext, Serilog") ??
								  Type.GetType("Serilog.Context.LogContext, Serilog.FullNetFx");

			MethodInfo pushPropertyMethod = ndcContextType.GetMethodPortable(
				"PushProperty",
				typeof(string),
				typeof(object),
				typeof(bool));

			ParameterExpression nameParam = Expression.Parameter(typeof(string), "name");
			ParameterExpression valueParam = Expression.Parameter(typeof(object), "value");
			ParameterExpression destructureObjectParam = Expression.Parameter(typeof(bool), "destructureObjects");
			MethodCallExpression pushPropertyMethodCall = Expression
				.Call(null, pushPropertyMethod, nameParam, valueParam, destructureObjectParam);
			Func<string, object, bool, IDisposable> pushProperty = Expression
				.Lambda<Func<string, object, bool, IDisposable>>(
					pushPropertyMethodCall,
					nameParam,
					valueParam,
					destructureObjectParam)
				.Compile();

			return (key, value) => pushProperty(key, value, false);
		}

		private static Type GetLogManagerType()
		{
			return Type.GetType("Serilog.Log, Serilog");
		}

		private static Func<string, object> GetForContextMethodCall()
		{
			Type logManagerType = GetLogManagerType();
			MethodInfo method = logManagerType.GetMethodPortable("ForContext", typeof(string), typeof(object), typeof(bool));
			ParameterExpression propertyNameParam = Expression.Parameter(typeof(string), "propertyName");
			ParameterExpression valueParam = Expression.Parameter(typeof(object), "value");
			ParameterExpression destructureObjectsParam = Expression.Parameter(typeof(bool), "destructureObjects");
			MethodCallExpression methodCall = Expression.Call(null, method, new Expression[]
			{
				propertyNameParam,
				valueParam,
				destructureObjectsParam
			});
			Func<string, object, bool, object> func = Expression.Lambda<Func<string, object, bool, object>>(
					methodCall,
					propertyNameParam,
					valueParam,
					destructureObjectsParam)
				.Compile();
			return name => func("SourceContext", name, false);
		}

#if !LIBLOG_PORTABLE
		[ExcludeFromCodeCoverage]
#endif
		internal class SerilogLogger
		{
			private readonly object _logger;
			private static readonly object _debugLevel;
			private static readonly object _errorLevel;
			private static readonly object _fatalLevel;
			private static readonly object _informationLevel;
			private static readonly object _verboseLevel;
			private static readonly object _warningLevel;
			private static readonly Func<object, object, bool> _isEnabled;
			private static readonly Action<object, object, string, object[]> _write;
			private static readonly Action<object, object, Exception, string, object[]> _writeException;

			[SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
			[SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
			[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "ILogger")]
			[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "LogEventLevel")]
			[SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "Serilog")]
			static SerilogLogger()
			{
				Type logEventLevelType = Type.GetType("Serilog.Events.LogEventLevel, Serilog");
				if (logEventLevelType == null)
				{
					throw new InvalidOperationException("Type Serilog.Events.LogEventLevel was not found.");
				}
				_debugLevel = Enum.Parse(logEventLevelType, "Debug", false);
				_errorLevel = Enum.Parse(logEventLevelType, "Error", false);
				_fatalLevel = Enum.Parse(logEventLevelType, "Fatal", false);
				_informationLevel = Enum.Parse(logEventLevelType, "Information", false);
				_verboseLevel = Enum.Parse(logEventLevelType, "Verbose", false);
				_warningLevel = Enum.Parse(logEventLevelType, "Warning", false);

				// Func<object, object, bool> isEnabled = (logger, level) => { return ((SeriLog.ILogger)logger).IsEnabled(level); }
				Type loggerType = Type.GetType("Serilog.ILogger, Serilog");
				if (loggerType == null)
				{
					throw new InvalidOperationException("Type Serilog.ILogger was not found.");
				}
				MethodInfo isEnabledMethodInfo = loggerType.GetMethodPortable("IsEnabled", logEventLevelType);
				ParameterExpression instanceParam = Expression.Parameter(typeof(object));
				UnaryExpression instanceCast = Expression.Convert(instanceParam, loggerType);
				ParameterExpression levelParam = Expression.Parameter(typeof(object));
				UnaryExpression levelCast = Expression.Convert(levelParam, logEventLevelType);
				MethodCallExpression isEnabledMethodCall = Expression.Call(instanceCast, isEnabledMethodInfo, levelCast);
				_isEnabled = Expression.Lambda<Func<object, object, bool>>(isEnabledMethodCall, instanceParam, levelParam).Compile();

				// Action<object, object, string> Write =
				// (logger, level, message, params) => { ((SeriLog.ILoggerILogger)logger).Write(level, message, params); }
				MethodInfo writeMethodInfo = loggerType.GetMethodPortable("Write", logEventLevelType, typeof(string), typeof(object[]));
				ParameterExpression messageParam = Expression.Parameter(typeof(string));
				ParameterExpression propertyValuesParam = Expression.Parameter(typeof(object[]));
				MethodCallExpression writeMethodExp = Expression.Call(
					instanceCast,
					writeMethodInfo,
					levelCast,
					messageParam,
					propertyValuesParam);
				Expression<Action<object, object, string, object[]>> expression = Expression.Lambda<Action<object, object, string, object[]>>(
					writeMethodExp,
					instanceParam,
					levelParam,
					messageParam,
					propertyValuesParam);
				_write = expression.Compile();

				// Action<object, object, string, Exception> WriteException =
				// (logger, level, exception, message) => { ((ILogger)logger).Write(level, exception, message, new object[]); }
				MethodInfo writeExceptionMethodInfo = loggerType.GetMethodPortable("Write",
					logEventLevelType,
					typeof(Exception),
					typeof(string),
					typeof(object[]));
				ParameterExpression exceptionParam = Expression.Parameter(typeof(Exception));
				writeMethodExp = Expression.Call(
					instanceCast,
					writeExceptionMethodInfo,
					levelCast,
					exceptionParam,
					messageParam,
					propertyValuesParam);
				_writeException = Expression.Lambda<Action<object, object, Exception, string, object[]>>(
					writeMethodExp,
					instanceParam,
					levelParam,
					exceptionParam,
					messageParam,
					propertyValuesParam).Compile();
			}

			internal SerilogLogger(object logger)
			{
				this._logger = logger;
			}

			public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception, params object[] formatParameters)
			{
				object translatedLevel = TranslateLevel(logLevel);
				if (messageFunc == null)
				{
					return _isEnabled(this._logger, translatedLevel);
				}

				if (!_isEnabled(this._logger, translatedLevel))
				{
					return false;
				}

				if (exception != null)
				{
					this.LogException(translatedLevel, messageFunc, exception, formatParameters);
				}
				else
				{
					this.LogMessage(translatedLevel, messageFunc, formatParameters);
				}

				return true;
			}

			private void LogMessage(object translatedLevel, Func<string> messageFunc, object[] formatParameters)
			{
				_write(this._logger, translatedLevel, messageFunc(), formatParameters);
			}

			private void LogException(object logLevel, Func<string> messageFunc, Exception exception, object[] formatParams)
			{
				_writeException(this._logger, logLevel, exception, messageFunc(), formatParams);
			}

			private static object TranslateLevel(LogLevel logLevel)
			{
				switch (logLevel)
				{
					case LogLevel.Fatal:
						return _fatalLevel;
					case LogLevel.Error:
						return _errorLevel;
					case LogLevel.Warn:
						return _warningLevel;
					case LogLevel.Info:
						return _informationLevel;
					case LogLevel.Trace:
						return _verboseLevel;
					default:
						return _debugLevel;
				}
			}
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class LoupeLogProvider : LogProviderBase
	{
		/// <summary>
		/// The form of the Loupe Log.Write method we're using
		/// </summary>
		internal delegate void WriteDelegate(
			int severity,
			string logSystem,
			int skipFrames,
			Exception exception,
			bool attributeToException,
			int writeMode,
			string detailsXml,
			string category,
			string caption,
			string description,
			params object[] args
		);

		private readonly WriteDelegate _logWriteDelegate;

		public LoupeLogProvider()
		{
			if (!IsLoggerAvailable())
			{
				throw new InvalidOperationException("Gibraltar.Agent.Log (Loupe) not found");
			}

			this._logWriteDelegate = GetLogWriteDelegate();
		}

		/// <summary>
		/// Gets or sets a value indicating whether [provider is available override]. Used in tests.
		/// </summary>
		/// <value>
		/// <c>true</c> if [provider is available override]; otherwise, <c>false</c>.
		/// </value>
		public static bool ProviderIsAvailableOverride { get; set; } = true;

		public override Logger GetLogger(string name)
		{
			return new LoupeLogger(name, this._logWriteDelegate).Log;
		}

		public static bool IsLoggerAvailable()
		{
			return ProviderIsAvailableOverride && GetLogManagerType() != null;
		}

		private static Type GetLogManagerType()
		{
			return Type.GetType("Gibraltar.Agent.Log, Gibraltar.Agent");
		}

		private static WriteDelegate GetLogWriteDelegate()
		{
			Type logManagerType = GetLogManagerType();
			Type logMessageSeverityType = Type.GetType("Gibraltar.Agent.LogMessageSeverity, Gibraltar.Agent");
			Type logWriteModeType = Type.GetType("Gibraltar.Agent.LogWriteMode, Gibraltar.Agent");

			MethodInfo method = logManagerType.GetMethodPortable(
				"Write",
				logMessageSeverityType, typeof(string), typeof(int), typeof(Exception), typeof(bool),
				logWriteModeType, typeof(string), typeof(string), typeof(string), typeof(string), typeof(object[]));

			WriteDelegate callDelegate = (WriteDelegate)method.CreateDelegate(typeof(WriteDelegate));
			return callDelegate;
		}

#if !LIBLOG_PORTABLE
		[ExcludeFromCodeCoverage]
#endif
		internal class LoupeLogger
		{
			private const string LogSystem = "LibLog";

			private readonly string _category;
			private readonly WriteDelegate _logWriteDelegate;
			private readonly int _skipLevel;

			internal LoupeLogger(string category, WriteDelegate logWriteDelegate)
			{
				this._category = category;
				this._logWriteDelegate = logWriteDelegate;
#if DEBUG
				this._skipLevel = 2;
#else
                _skipLevel = 1;
#endif
			}

			public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception, params object[] formatParameters)
			{
				if (messageFunc == null)
				{
					//nothing to log..
					return true;
				}

				messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters);

				this._logWriteDelegate(ToLogMessageSeverity(logLevel), LogSystem, this._skipLevel, exception, true, 0, null, this._category, null, messageFunc.Invoke());

				return true;
			}

			private static int ToLogMessageSeverity(LogLevel logLevel)
			{
				switch (logLevel)
				{
					case LogLevel.Trace:
						return TraceEventTypeValues.Verbose;
					case LogLevel.Debug:
						return TraceEventTypeValues.Verbose;
					case LogLevel.Info:
						return TraceEventTypeValues.Information;
					case LogLevel.Warn:
						return TraceEventTypeValues.Warning;
					case LogLevel.Error:
						return TraceEventTypeValues.Error;
					case LogLevel.Fatal:
						return TraceEventTypeValues.Critical;
					default:
						throw new ArgumentOutOfRangeException(nameof(logLevel));
				}
			}
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal static class TraceEventTypeValues
	{
		internal static readonly Type Type;
		internal static readonly int Verbose;
		internal static readonly int Information;
		internal static readonly int Warning;
		internal static readonly int Error;
		internal static readonly int Critical;

		[SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
		static TraceEventTypeValues()
		{
			Assembly assembly = typeof(Uri).GetAssemblyPortable(); // This is to get to the System.dll assembly in a PCL compatible way.
			if (assembly == null)
			{
				return;
			}
			Type = assembly.GetType("System.Diagnostics.TraceEventType");
			if (Type == null) return;
			Verbose = (int)Enum.Parse(Type, "Verbose", false);
			Information = (int)Enum.Parse(Type, "Information", false);
			Warning = (int)Enum.Parse(Type, "Warning", false);
			Error = (int)Enum.Parse(Type, "Error", false);
			Critical = (int)Enum.Parse(Type, "Critical", false);
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal static class LogMessageFormatter
	{
		//private static readonly Regex Pattern = new Regex(@"\{@?\w{1,}\}");
#if LIBLOG_PORTABLE
		private static readonly Regex _pattern = new(@"(?<!{){@?(?<arg>[^\d{][^ }]*)}");
#else
		private static readonly Regex Pattern = new Regex(@"(?<!{){@?(?<arg>[^ :{}]+)(?<format>:[^}]+)?}", RegexOptions.Compiled);
#endif

		/// <summary>
		/// Some logging frameworks support structured logging, such as serilog. This will allow you to add names to structured data in a format string:
		/// For example: Log("Log message to {user}", user). This only works with serilog, but as the user of LibLog, you don't know if serilog is actually 
		/// used. So, this class simulates that. it will replace any text in {curly braces} with an index number. 
		/// 
		/// "Log {message} to {user}" would turn into => "Log {0} to {1}". Then the format parameters are handled using regular .net string.Format.
		/// </summary>
		/// <param name="messageBuilder">The message builder.</param>
		/// <param name="formatParameters">The format parameters.</param>
		/// <returns></returns>
		public static Func<string> SimulateStructuredLogging(Func<string> messageBuilder, object[] formatParameters)
		{
			if (formatParameters == null || formatParameters.Length == 0)
			{
				return messageBuilder;
			}

			return () =>
			{
				string targetMessage = messageBuilder();
				IEnumerable<string> patternMatches;
				return FormatStructuredMessage(targetMessage, formatParameters, out patternMatches);
			};
		}

		private static string ReplaceFirst(string text, string search, string replace)
		{
			int pos = text.IndexOf(search, StringComparison.Ordinal);
			if (pos < 0)
			{
				return text;
			}
			return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
		}

		public static string FormatStructuredMessage(string targetMessage, object[] formatParameters, out IEnumerable<string> patternMatches)
		{
			if (formatParameters.Length == 0)
			{
				patternMatches = Enumerable.Empty<string>();
				return targetMessage;
			}

			List<string> processedArguments = new();
			patternMatches = processedArguments;

			foreach (Match match in _pattern.Matches(targetMessage))
			{
				string arg = match.Groups["arg"].Value;

				int notUsed;
				if (!int.TryParse(arg, out notUsed))
				{
					int argumentIndex = processedArguments.IndexOf(arg);
					if (argumentIndex == -1)
					{
						argumentIndex = processedArguments.Count;
						processedArguments.Add(arg);
					}

					targetMessage = ReplaceFirst(targetMessage, match.Value,
						"{" + argumentIndex + match.Groups["format"].Value + "}");
				}
			}
			try
			{
				return string.Format(CultureInfo.InvariantCulture, targetMessage, formatParameters);
			}
			catch (FormatException ex)
			{
				throw new FormatException("The input string '" + targetMessage + "' could not be formatted using string.Format", ex);
			}
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal static class TypeExtensions
	{
		internal static ConstructorInfo GetConstructorPortable(this Type type, params Type[] types)
		{
#if LIBLOG_PORTABLE
			return type.GetTypeInfo().DeclaredConstructors.FirstOrDefault
					   (constructor =>
							constructor.GetParameters()
									   .Select(parameter => parameter.ParameterType)
									   .SequenceEqual(types));
#else
			return type.GetConstructor(types);
#endif
		}

		internal static MethodInfo GetMethodPortable(this Type type, string name)
		{
#if LIBLOG_PORTABLE
			return type.GetRuntimeMethods().SingleOrDefault(m => m.Name == name);
#else
			return type.GetMethod(name);
#endif
		}

		internal static MethodInfo GetMethodPortable(this Type type, string name, params Type[] types)
		{
#if LIBLOG_PORTABLE
			return type.GetRuntimeMethod(name, types);
#else
			return type.GetMethod(name, types);
#endif
		}

		internal static PropertyInfo GetPropertyPortable(this Type type, string name)
		{
#if LIBLOG_PORTABLE
			return type.GetRuntimeProperty(name);
#else
			return type.GetProperty(name);
#endif
		}

		internal static IEnumerable<FieldInfo> GetFieldsPortable(this Type type)
		{
#if LIBLOG_PORTABLE
			return type.GetRuntimeFields();
#else
			return type.GetFields();
#endif
		}

		internal static Type GetBaseTypePortable(this Type type)
		{
#if LIBLOG_PORTABLE
			return type.GetTypeInfo().BaseType;
#else
			return type.BaseType;
#endif
		}

#if LIBLOG_PORTABLE
		internal static MethodInfo GetGetMethod(this PropertyInfo propertyInfo)
		{
			return propertyInfo.GetMethod;
		}

		internal static MethodInfo GetSetMethod(this PropertyInfo propertyInfo)
		{
			return propertyInfo.SetMethod;
		}
#endif

#if !LIBLOG_PORTABLE
		internal static object CreateDelegate(this MethodInfo methodInfo, Type delegateType)
		{
			return Delegate.CreateDelegate(delegateType, methodInfo);
		}
#endif

		internal static Assembly GetAssemblyPortable(this Type type)
		{
#if LIBLOG_PORTABLE
			return type.GetTypeInfo().Assembly;
#else
			return type.Assembly;
#endif
		}
	}

#if !LIBLOG_PORTABLE
	[ExcludeFromCodeCoverage]
#endif
	internal class DisposableAction : IDisposable
	{
		private readonly Action _onDispose;

		public DisposableAction(Action onDispose = null)
		{
			this._onDispose = onDispose;
		}

		public void Dispose()
		{
			this._onDispose?.Invoke();
		}
	}
}
